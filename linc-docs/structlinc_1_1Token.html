<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>linc: linc::Token Struct Reference</title>
<link rel="icon" href="linc64.png" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="linc64.png"/></td>
  <td id="projectalign">
   <div id="projectname">linc<span id="projectnumber">&#160;0.6.1</span>
   </div>
   <div id="projectbrief">Linc is a general-purpose programming language inspired by C</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>linc</b></li><li class="navelem"><a class="el" href="structlinc_1_1Token.html">Token</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structlinc_1_1Token-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">linc::Token Struct Reference<span class="mlabels"><span class="mlabel">final</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Aggregate structure used by the lexer to abstract from raw code, such that the parser does not have to deal code on an individual character basis.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;Token.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlinc_1_1Token_1_1Info.html">Info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct holding data useful for error handling and logging.  <a href="structlinc_1_1Token_1_1Info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a94054fb75d1803c64d650e71756d53fe" id="r_a94054fb75d1803c64d650e71756d53fe"><td class="memItemLeft" align="right" valign="top"><a id="a94054fb75d1803c64d650e71756d53fe" name="a94054fb75d1803c64d650e71756d53fe"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94054fb75d1803c64d650e71756d53fe">Type</a> { <br />
&#160;&#160;<b>InvalidToken</b>
, <b>EndOfFile</b>
, <b>KeywordReturn</b>
, <b>KeywordFunction</b>
, <br />
&#160;&#160;<b>KeywordIf</b>
, <b>KeywordElse</b>
, <b>KeywordWhile</b>
, <b>KeywordTrue</b>
, <br />
&#160;&#160;<b>KeywordFalse</b>
, <b>KeywordMutability</b>
, <b>KeywordFinally</b>
, <b>KeywordAs</b>
, <br />
&#160;&#160;<b>KeywordFor</b>
, <b>KeywordIn</b>
, <b>KeywordExternal</b>
, <b>KeywordJump</b>
, <br />
&#160;&#160;<b>KeywordBreak</b>
, <b>KeywordContinue</b>
, <b>KeywordStructure</b>
, <b>ParenthesisLeft</b>
, <br />
&#160;&#160;<b>ParenthesisRight</b>
, <b>SquareLeft</b>
, <b>SquareRight</b>
, <b>BraceLeft</b>
, <br />
&#160;&#160;<b>BraceRight</b>
, <b>Colon</b>
, <b>Comma</b>
, <b>Tilde</b>
, <br />
&#160;&#160;<b>Dot</b>
, <b>PreprocessorSpecifier</b>
, <b>GlueSpecifier</b>
, <b>OperatorPlus</b>
, <br />
&#160;&#160;<b>OperatorMinus</b>
, <b>OperatorAsterisk</b>
, <b>OperatorSlash</b>
, <b>OperatorPercent</b>
, <br />
&#160;&#160;<b>OperatorIncrement</b>
, <b>OperatorDecrement</b>
, <b>OperatorStringify</b>
, <b>OperatorAssignment</b>
, <br />
&#160;&#160;<b>OperatorAsignmentAddition</b>
, <b>OperatorAsignmentSubstraction</b>
, <b>OperatorAssignmentMultiplication</b>
, <b>OperatorAssignmentDivision</b>
, <br />
&#160;&#160;<b>OperatorAssignmentModulo</b>
, <b>OperatorEquals</b>
, <b>OperatorNotEquals</b>
, <b>OperatorGreater</b>
, <br />
&#160;&#160;<b>OperatorLess</b>
, <b>OperatorGreaterEqual</b>
, <b>OperatorLessEqual</b>
, <b>OperatorLogicalAnd</b>
, <br />
&#160;&#160;<b>OperatorLogicalOr</b>
, <b>OperatorLogicalNot</b>
, <b>OperatorBitwiseAnd</b>
, <b>OperatorBitwiseOr</b>
, <br />
&#160;&#160;<b>OperatorBitwiseXor</b>
, <b>OperatorBitwiseNot</b>
, <b>OperatorBitwiseShiftLeft</b>
, <b>OperatorBitwiseShiftRight</b>
, <br />
&#160;&#160;<b>I8Literal</b>
, <b>I16Literal</b>
, <b>I32Literal</b>
, <b>I64Literal</b>
, <br />
&#160;&#160;<b>U8Literal</b>
, <b>U16Literal</b>
, <b>U32Literal</b>
, <b>U64Literal</b>
, <br />
&#160;&#160;<b>F32Literal</b>
, <b>F64Literal</b>
, <b>StringLiteral</b>
, <b>CharacterLiteral</b>
, <br />
&#160;&#160;<b>Identifier</b>
<br />
 }</td></tr>
<tr class="memdesc:a94054fb75d1803c64d650e71756d53fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a <a class="el" href="structlinc_1_1Token.html" title="Aggregate structure used by the lexer to abstract from raw code, such that the parser does not have t...">Token</a>. <br /></td></tr>
<tr class="separator:a94054fb75d1803c64d650e71756d53fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48500aa126914866483339efb5179c93" id="r_a48500aa126914866483339efb5179c93"><td class="memItemLeft" align="right" valign="top"><a id="a48500aa126914866483339efb5179c93" name="a48500aa126914866483339efb5179c93"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48500aa126914866483339efb5179c93">NumberBase</a> : unsigned char { <b>Decimal</b>
, <b>Hexadecimal</b>
, <b>Binary</b>
 }</td></tr>
<tr class="memdesc:a48500aa126914866483339efb5179c93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of supported number system bases. <br /></td></tr>
<tr class="separator:a48500aa126914866483339efb5179c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acd16e31a61c0eb4a66e8882efe8ead40" id="r_acd16e31a61c0eb4a66e8882efe8ead40"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd16e31a61c0eb4a66e8882efe8ead40">isValid</a> () const</td></tr>
<tr class="memdesc:acd16e31a61c0eb4a66e8882efe8ead40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether this token is valid- not of the 'InvalidToken' type.  <br /></td></tr>
<tr class="separator:acd16e31a61c0eb4a66e8882efe8ead40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21fd5f0bad4d7fe5f1dcf2cb82338b79" id="r_a21fd5f0bad4d7fe5f1dcf2cb82338b79"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21fd5f0bad4d7fe5f1dcf2cb82338b79">isLiteral</a> () const</td></tr>
<tr class="memdesc:a21fd5f0bad4d7fe5f1dcf2cb82338b79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether this token is a literal. Literals include character literals (e.g. 'c', 60c), string literals (e.g. "hello world"), integer literals (e.g. 10u8, 10i16), boolean literals(true, false, 1b).  <br /></td></tr>
<tr class="separator:a21fd5f0bad4d7fe5f1dcf2cb82338b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b36f64f4dcc3745f19d1db05b4949d9" id="r_a2b36f64f4dcc3745f19d1db05b4949d9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b36f64f4dcc3745f19d1db05b4949d9">isKeyword</a> () const</td></tr>
<tr class="memdesc:a2b36f64f4dcc3745f19d1db05b4949d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether this token is a keyword. <a class="el" href="classlinc_1_1Keywords.html" title="Lexer-token representation of keywords.">Keywords</a> are reserved character sequences that follow the same rules as identifiers, but serve a unique purpose in the language (e.g. if, true, return, while).  <br /></td></tr>
<tr class="separator:a2b36f64f4dcc3745f19d1db05b4949d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4210a904204e8806969664798c72cc2d" id="r_a4210a904204e8806969664798c72cc2d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4210a904204e8806969664798c72cc2d">isSymbol</a> () const</td></tr>
<tr class="memdesc:a4210a904204e8806969664798c72cc2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether this token is a symbol. Symbols are, like operators, character sequences which serve a specific purpose in the language. Unlike operators, Symbols don't necessarily 'act' on a given operand, but are used purely for syntactical purposes (e.g. to specify a function's return type, to group statements into a scope).  <br /></td></tr>
<tr class="separator:a4210a904204e8806969664798c72cc2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aad575b23d3ab967ed31f930d496036" id="r_a9aad575b23d3ab967ed31f930d496036"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9aad575b23d3ab967ed31f930d496036">isIdentifier</a> () const</td></tr>
<tr class="memdesc:a9aad575b23d3ab967ed31f930d496036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether this token is an identifier. Identifiers are non-reserved sequences of alphanumeric(plus '_') characters used to 'identify', as the name suggests, structures like functions and variables. An identifier cannot, however, have a digit as its first character.  <br /></td></tr>
<tr class="separator:a9aad575b23d3ab967ed31f930d496036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab201e360e57392e7da3b827bc6b2520f" id="r_ab201e360e57392e7da3b827bc6b2520f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab201e360e57392e7da3b827bc6b2520f">isEndOfFile</a> () const</td></tr>
<tr class="memdesc:ab201e360e57392e7da3b827bc6b2520f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether this token is the end of a file. This token has been conventionally used to ease the parsing process, and is thus, also used int his project. EOF tokens are only produced at the end of files by the lexer. This means that no sequence of characters can 'emit' and end of File token as its output.  <br /></td></tr>
<tr class="separator:ab201e360e57392e7da3b827bc6b2520f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2446e74f776bdaac2106a93c99e42fca" id="r_a2446e74f776bdaac2106a93c99e42fca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2446e74f776bdaac2106a93c99e42fca">isOperator</a> () const</td></tr>
<tr class="memdesc:a2446e74f776bdaac2106a93c99e42fca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether this token is an operator. <a class="el" href="classlinc_1_1Operators.html" title="Token representation of operators, operator precedence and associativity mapping.">Operators</a> are special characters that return the result of an operation that has been 'acted' upon a value. <a class="el" href="classlinc_1_1Operators.html" title="Token representation of operators, operator precedence and associativity mapping.">Operators</a> are split into two primary categories: unary operators (those who modify a singular value, e.g. the unary negation operator), and binary operators (those who modify two values, e.g. the basic arithmetic operators of addition, subtraction, multiplication and division).  <br /></td></tr>
<tr class="separator:a2446e74f776bdaac2106a93c99e42fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36a4cc5a69d593080ed26545e7d0dbd7" id="r_a36a4cc5a69d593080ed26545e7d0dbd7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36a4cc5a69d593080ed26545e7d0dbd7">isAssignmentOperator</a> () const</td></tr>
<tr class="memdesc:a36a4cc5a69d593080ed26545e7d0dbd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether this token is an assignment operator. Assignment operators include the 'main assignment operator' —typically used to assign a value to a given variable—, as well as all arithmetic assignment operators, which are equivelant to assignments of arithmetic binary operations to a variable, where the first operand is the same as the variable.  <br /></td></tr>
<tr class="separator:a36a4cc5a69d593080ed26545e7d0dbd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1449b748dee87a4f80118c0974a27fe6" id="r_a1449b748dee87a4f80118c0974a27fe6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1449b748dee87a4f80118c0974a27fe6">isArithmeticOperator</a> () const</td></tr>
<tr class="memdesc:a1449b748dee87a4f80118c0974a27fe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether this token is an arithmetic operator. Arithmetic operators are those where all operands are numbers, and where the return value of the operation is also a number (e.g. addition, multiplication, negation, increment). Note: the arithmetic assignment operators are NOT arithmetic operators, since the assignment ones mutate a variable, and thus, cannot be applied to all number values.  <br /></td></tr>
<tr class="separator:a1449b748dee87a4f80118c0974a27fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac83989416b2bfbf78474a80d1fc21698" id="r_ac83989416b2bfbf78474a80d1fc21698"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac83989416b2bfbf78474a80d1fc21698">isArithmeticAssignmentOperator</a> () const</td></tr>
<tr class="memdesc:ac83989416b2bfbf78474a80d1fc21698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether this token is an arithmetic assignment operator. Arithmetic assignment operators are equivelant to their corresponding binary arithmetic operators, with the first operand being a variable, which the result of the operation is also assigned to.  <br /></td></tr>
<tr class="separator:ac83989416b2bfbf78474a80d1fc21698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7fd2306bf7251d5f62a6e0e1206e8a" id="r_abc7fd2306bf7251d5f62a6e0e1206e8a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc7fd2306bf7251d5f62a6e0e1206e8a">isComparisonOperator</a> () const</td></tr>
<tr class="memdesc:abc7fd2306bf7251d5f62a6e0e1206e8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether this token is a comparison operator. Comparison operators are binary operators where the output is a boolean (e.g. the greater-than operator, the equality operator). Note: these operators operate solely on numbers, with the exception of the equality and inequality operators, which operate on any given type.  <br /></td></tr>
<tr class="separator:abc7fd2306bf7251d5f62a6e0e1206e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f3939058786f2576c00086dff630f37" id="r_a6f3939058786f2576c00086dff630f37"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f3939058786f2576c00086dff630f37">isLogicalOperator</a> () const</td></tr>
<tr class="memdesc:a6f3939058786f2576c00086dff630f37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether this token is a logical operator. Logical operators are operators where both the operands and the return value are of boolean type, corresponding to basic statement logical operators in math (and, or, not).  <br /></td></tr>
<tr class="separator:a6f3939058786f2576c00086dff630f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adabb68a0251284a7d0b4d1397cfb988d" id="r_adabb68a0251284a7d0b4d1397cfb988d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adabb68a0251284a7d0b4d1397cfb988d">isBitwiseOperator</a> () const</td></tr>
<tr class="memdesc:adabb68a0251284a7d0b4d1397cfb988d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether this token is a bitwise operator. Bitwise operators are those where both the operands are integrals, and where an operation is applied to each of their individual bits. The most common bitwise operators correspond to the logical ones, but on a bit-wise level (bitwise and, bitwise or, bitwise not). Additional ones include bitwise xor, bitshift-left, bitshift-right, etc...  <br /></td></tr>
<tr class="separator:adabb68a0251284a7d0b4d1397cfb988d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e8795240165e1c47d9f5a0d6f2a485" id="r_af0e8795240165e1c47d9f5a0d6f2a485"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0e8795240165e1c47d9f5a0d6f2a485">isBinaryOperator</a> () const</td></tr>
<tr class="memdesc:af0e8795240165e1c47d9f5a0d6f2a485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether this token is a binary operator. Binary operators are those that are applied to exactly two operands.  <br /></td></tr>
<tr class="separator:af0e8795240165e1c47d9f5a0d6f2a485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbff7fab7e0e8ed46da4d11db8bc4420" id="r_afbff7fab7e0e8ed46da4d11db8bc4420"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afbff7fab7e0e8ed46da4d11db8bc4420">isUnaryOperator</a> () const</td></tr>
<tr class="memdesc:afbff7fab7e0e8ed46da4d11db8bc4420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether this token is a unary operator. Unary operators are those that are applied to only a singular operand.  <br /></td></tr>
<tr class="separator:afbff7fab7e0e8ed46da4d11db8bc4420"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a21135eab5531941e2392569ac9d35b58" id="r_a21135eab5531941e2392569ac9d35b58"><td class="memItemLeft" align="right" valign="top">static unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21135eab5531941e2392569ac9d35b58">baseToInt</a> (<a class="el" href="#a48500aa126914866483339efb5179c93">Token::NumberBase</a> base)</td></tr>
<tr class="memdesc:a21135eab5531941e2392569ac9d35b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a given number base to its corresponding integer (in decimal).  <br /></td></tr>
<tr class="separator:a21135eab5531941e2392569ac9d35b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37af0e80202205c63767dbf5965b8428" id="r_a37af0e80202205c63767dbf5965b8428"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37af0e80202205c63767dbf5965b8428">typeToString</a> (<a class="el" href="#a94054fb75d1803c64d650e71756d53fe">Type</a> type)</td></tr>
<tr class="memdesc:a37af0e80202205c63767dbf5965b8428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a given token type to a string, essential for error handling/debugging/IO.  <br /></td></tr>
<tr class="separator:a37af0e80202205c63767dbf5965b8428"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a5f26a6a0561159487b743613e2a3f66e" id="r_a5f26a6a0561159487b743613e2a3f66e"><td class="memItemLeft" align="right" valign="top"><a id="a5f26a6a0561159487b743613e2a3f66e" name="a5f26a6a0561159487b743613e2a3f66e"></a>
<a class="el" href="#a94054fb75d1803c64d650e71756d53fe">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>type</b></td></tr>
<tr class="separator:a5f26a6a0561159487b743613e2a3f66e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366d8d4ba000373c5c6ec2e81e9a0644" id="r_a366d8d4ba000373c5c6ec2e81e9a0644"><td class="memItemLeft" align="right" valign="top"><a id="a366d8d4ba000373c5c6ec2e81e9a0644" name="a366d8d4ba000373c5c6ec2e81e9a0644"></a>
std::optional&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>value</b></td></tr>
<tr class="separator:a366d8d4ba000373c5c6ec2e81e9a0644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede550804f4f6bd696e92114adb6fd58" id="r_aede550804f4f6bd696e92114adb6fd58"><td class="memItemLeft" align="right" valign="top"><a id="aede550804f4f6bd696e92114adb6fd58" name="aede550804f4f6bd696e92114adb6fd58"></a>
std::optional&lt; <a class="el" href="#a48500aa126914866483339efb5179c93">NumberBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>numberBase</b></td></tr>
<tr class="separator:aede550804f4f6bd696e92114adb6fd58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad09d797e7509a41b12a8c9a08659d260" id="r_ad09d797e7509a41b12a8c9a08659d260"><td class="memItemLeft" align="right" valign="top"><a id="ad09d797e7509a41b12a8c9a08659d260" name="ad09d797e7509a41b12a8c9a08659d260"></a>
<a class="el" href="structlinc_1_1Token_1_1Info.html">Info</a>&#160;</td><td class="memItemRight" valign="bottom"><b>info</b></td></tr>
<tr class="separator:ad09d797e7509a41b12a8c9a08659d260"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Aggregate structure used by the lexer to abstract from raw code, such that the parser does not have to deal code on an individual character basis. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a21135eab5531941e2392569ac9d35b58" name="a21135eab5531941e2392569ac9d35b58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21135eab5531941e2392569ac9d35b58">&#9670;&#160;</a></span>baseToInt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char linc::Token::baseToInt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a48500aa126914866483339efb5179c93">Token::NumberBase</a></td>          <td class="paramname"><span class="paramname"><em>base</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a given number base to its corresponding integer (in decimal). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base enumerator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unsigned char (integer) corresponding to the number base. </dd></dl>

</div>
</div>
<a id="ac83989416b2bfbf78474a80d1fc21698" name="ac83989416b2bfbf78474a80d1fc21698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac83989416b2bfbf78474a80d1fc21698">&#9670;&#160;</a></span>isArithmeticAssignmentOperator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool linc::Token::isArithmeticAssignmentOperator </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether this token is an arithmetic assignment operator. Arithmetic assignment operators are equivelant to their corresponding binary arithmetic operators, with the first operand being a variable, which the result of the operation is also assigned to. </p>
<dl class="section return"><dt>Returns</dt><dd>Boolean corresponding to the result of the test. </dd></dl>

</div>
</div>
<a id="a1449b748dee87a4f80118c0974a27fe6" name="a1449b748dee87a4f80118c0974a27fe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1449b748dee87a4f80118c0974a27fe6">&#9670;&#160;</a></span>isArithmeticOperator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool linc::Token::isArithmeticOperator </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether this token is an arithmetic operator. Arithmetic operators are those where all operands are numbers, and where the return value of the operation is also a number (e.g. addition, multiplication, negation, increment). Note: the arithmetic assignment operators are NOT arithmetic operators, since the assignment ones mutate a variable, and thus, cannot be applied to all number values. </p>
<dl class="section return"><dt>Returns</dt><dd>Boolean corresponding to the result of the test. </dd></dl>

</div>
</div>
<a id="a36a4cc5a69d593080ed26545e7d0dbd7" name="a36a4cc5a69d593080ed26545e7d0dbd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36a4cc5a69d593080ed26545e7d0dbd7">&#9670;&#160;</a></span>isAssignmentOperator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool linc::Token::isAssignmentOperator </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether this token is an assignment operator. Assignment operators include the 'main assignment operator' —typically used to assign a value to a given variable—, as well as all arithmetic assignment operators, which are equivelant to assignments of arithmetic binary operations to a variable, where the first operand is the same as the variable. </p>
<dl class="section return"><dt>Returns</dt><dd>Boolean corresponding to the result of the test. </dd></dl>

</div>
</div>
<a id="af0e8795240165e1c47d9f5a0d6f2a485" name="af0e8795240165e1c47d9f5a0d6f2a485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0e8795240165e1c47d9f5a0d6f2a485">&#9670;&#160;</a></span>isBinaryOperator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool linc::Token::isBinaryOperator </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether this token is a binary operator. Binary operators are those that are applied to exactly two operands. </p>
<dl class="section return"><dt>Returns</dt><dd>Boolean corresponding to the result of the test. </dd></dl>

</div>
</div>
<a id="adabb68a0251284a7d0b4d1397cfb988d" name="adabb68a0251284a7d0b4d1397cfb988d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adabb68a0251284a7d0b4d1397cfb988d">&#9670;&#160;</a></span>isBitwiseOperator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool linc::Token::isBitwiseOperator </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether this token is a bitwise operator. Bitwise operators are those where both the operands are integrals, and where an operation is applied to each of their individual bits. The most common bitwise operators correspond to the logical ones, but on a bit-wise level (bitwise and, bitwise or, bitwise not). Additional ones include bitwise xor, bitshift-left, bitshift-right, etc... </p>
<dl class="section return"><dt>Returns</dt><dd>Boolean corresponding to the result of the test. </dd></dl>

</div>
</div>
<a id="abc7fd2306bf7251d5f62a6e0e1206e8a" name="abc7fd2306bf7251d5f62a6e0e1206e8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc7fd2306bf7251d5f62a6e0e1206e8a">&#9670;&#160;</a></span>isComparisonOperator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool linc::Token::isComparisonOperator </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether this token is a comparison operator. Comparison operators are binary operators where the output is a boolean (e.g. the greater-than operator, the equality operator). Note: these operators operate solely on numbers, with the exception of the equality and inequality operators, which operate on any given type. </p>
<dl class="section return"><dt>Returns</dt><dd>Boolean corresponding to the result of the test. </dd></dl>

</div>
</div>
<a id="ab201e360e57392e7da3b827bc6b2520f" name="ab201e360e57392e7da3b827bc6b2520f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab201e360e57392e7da3b827bc6b2520f">&#9670;&#160;</a></span>isEndOfFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool linc::Token::isEndOfFile </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether this token is the end of a file. This token has been conventionally used to ease the parsing process, and is thus, also used int his project. EOF tokens are only produced at the end of files by the lexer. This means that no sequence of characters can 'emit' and end of File token as its output. </p>
<dl class="section return"><dt>Returns</dt><dd>Boolean corresponding to the result of the test. </dd></dl>

</div>
</div>
<a id="a9aad575b23d3ab967ed31f930d496036" name="a9aad575b23d3ab967ed31f930d496036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aad575b23d3ab967ed31f930d496036">&#9670;&#160;</a></span>isIdentifier()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool linc::Token::isIdentifier </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether this token is an identifier. Identifiers are non-reserved sequences of alphanumeric(plus '_') characters used to 'identify', as the name suggests, structures like functions and variables. An identifier cannot, however, have a digit as its first character. </p>
<dl class="section return"><dt>Returns</dt><dd>Boolean corresponding to the result of the test. </dd></dl>

</div>
</div>
<a id="a2b36f64f4dcc3745f19d1db05b4949d9" name="a2b36f64f4dcc3745f19d1db05b4949d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b36f64f4dcc3745f19d1db05b4949d9">&#9670;&#160;</a></span>isKeyword()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool linc::Token::isKeyword </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether this token is a keyword. <a class="el" href="classlinc_1_1Keywords.html" title="Lexer-token representation of keywords.">Keywords</a> are reserved character sequences that follow the same rules as identifiers, but serve a unique purpose in the language (e.g. if, true, return, while). </p>
<dl class="section return"><dt>Returns</dt><dd>Boolean corresponding to the result of the test. </dd></dl>

</div>
</div>
<a id="a21fd5f0bad4d7fe5f1dcf2cb82338b79" name="a21fd5f0bad4d7fe5f1dcf2cb82338b79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21fd5f0bad4d7fe5f1dcf2cb82338b79">&#9670;&#160;</a></span>isLiteral()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool linc::Token::isLiteral </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether this token is a literal. Literals include character literals (e.g. 'c', 60c), string literals (e.g. "hello world"), integer literals (e.g. 10u8, 10i16), boolean literals(true, false, 1b). </p>
<dl class="section return"><dt>Returns</dt><dd>Boolean corresponding to the result of the test. </dd></dl>

</div>
</div>
<a id="a6f3939058786f2576c00086dff630f37" name="a6f3939058786f2576c00086dff630f37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f3939058786f2576c00086dff630f37">&#9670;&#160;</a></span>isLogicalOperator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool linc::Token::isLogicalOperator </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether this token is a logical operator. Logical operators are operators where both the operands and the return value are of boolean type, corresponding to basic statement logical operators in math (and, or, not). </p>
<dl class="section return"><dt>Returns</dt><dd>Boolean corresponding to the result of the test. </dd></dl>

</div>
</div>
<a id="a2446e74f776bdaac2106a93c99e42fca" name="a2446e74f776bdaac2106a93c99e42fca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2446e74f776bdaac2106a93c99e42fca">&#9670;&#160;</a></span>isOperator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool linc::Token::isOperator </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether this token is an operator. <a class="el" href="classlinc_1_1Operators.html" title="Token representation of operators, operator precedence and associativity mapping.">Operators</a> are special characters that return the result of an operation that has been 'acted' upon a value. <a class="el" href="classlinc_1_1Operators.html" title="Token representation of operators, operator precedence and associativity mapping.">Operators</a> are split into two primary categories: unary operators (those who modify a singular value, e.g. the unary negation operator), and binary operators (those who modify two values, e.g. the basic arithmetic operators of addition, subtraction, multiplication and division). </p>
<dl class="section return"><dt>Returns</dt><dd>Boolean corresponding to the result of the test. </dd></dl>

</div>
</div>
<a id="a4210a904204e8806969664798c72cc2d" name="a4210a904204e8806969664798c72cc2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4210a904204e8806969664798c72cc2d">&#9670;&#160;</a></span>isSymbol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool linc::Token::isSymbol </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether this token is a symbol. Symbols are, like operators, character sequences which serve a specific purpose in the language. Unlike operators, Symbols don't necessarily 'act' on a given operand, but are used purely for syntactical purposes (e.g. to specify a function's return type, to group statements into a scope). </p>
<dl class="section return"><dt>Returns</dt><dd>Boolean corresponding to the result of the test. </dd></dl>

</div>
</div>
<a id="afbff7fab7e0e8ed46da4d11db8bc4420" name="afbff7fab7e0e8ed46da4d11db8bc4420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbff7fab7e0e8ed46da4d11db8bc4420">&#9670;&#160;</a></span>isUnaryOperator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool linc::Token::isUnaryOperator </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether this token is a unary operator. Unary operators are those that are applied to only a singular operand. </p>
<dl class="section return"><dt>Returns</dt><dd>Boolean corresponding to the result of the test. </dd></dl>

</div>
</div>
<a id="acd16e31a61c0eb4a66e8882efe8ead40" name="acd16e31a61c0eb4a66e8882efe8ead40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd16e31a61c0eb4a66e8882efe8ead40">&#9670;&#160;</a></span>isValid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool linc::Token::isValid </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether this token is valid- not of the 'InvalidToken' type. </p>
<dl class="section return"><dt>Returns</dt><dd>Boolean corresponding to the result of the test. </dd></dl>

</div>
</div>
<a id="a37af0e80202205c63767dbf5965b8428" name="a37af0e80202205c63767dbf5965b8428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37af0e80202205c63767dbf5965b8428">&#9670;&#160;</a></span>typeToString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string linc::Token::typeToString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a94054fb75d1803c64d650e71756d53fe">Type</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a given token type to a string, essential for error handling/debugging/IO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of the token, to be converted to string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String corresponding to the given token type. </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li><b>Token.hpp</b></li>
<li><b>Token.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
